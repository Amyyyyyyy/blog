<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于BFC我有一点理解]]></title>
    <url>%2F2018%2F03%2F07%2F%E5%85%B3%E4%BA%8EBFC%E6%88%91%E6%9C%89%E8%AF%9D%E6%83%B3%E8%AF%B4%2F</url>
    <content type="text"><![CDATA[尝试理解BFC以前一直对BFC理解得很模糊，然后最近又去重新了解了下谷歌一搜关键词，几乎全是冲着对BFC定义来的，然鹅，并看不懂啊，汗颜。于是就根据MDN里面的BFC一些特性自己写了些样式试了下，有一句话真的说得很好，I KNOW IT WHEN I SEE IT意思就是只有我试了，我才理解了，这个BFC到底是个什么鬼东西。 以下是过程(哭泣脸):BFC: block formatting context – 快格式化上下文 MDN对BFC的定义：MDN块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。 下列方式会创建块格式化上下文： 根元素或包含根元素的元素 浮动元素（元素的 float 不是 none） 绝对定位元素（元素的 position 为 absolute 或 fixed） 行内块元素（元素的 display 为 inline-block） 表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值） 表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值） 匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table） overflow 值不为 visible 的块元素 display 值为 flow-root 的元素 contain 值为 layout、content或 strict 的元素 弹性元素（display为 flex 或 inline-flex元素的直接子元素） 网格元素（display为 grid 或 inline-grid 元素的直接子元素） 多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1） column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。 创建了块格式化上下文的元素中的所有内容都会被包含到该BFC中。 块格式化上下文对浮动定位（参见 float）与清除浮动（参见 clear）都很重要。浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（Margin collapsing）也只会发生在属于同一BFC的块级元素之间。 but 看不懂啊写得奇奇怪怪的~于是 我就挑了上述几个方式试了下：1 浮动元素会自动触发BFC我定义了两个div 一个是爸爸一个是儿子‘’’ / BFC就是可以直接把其内部的浮动元素包裹起来 / .baba{ border: 10px solid red; min-height: 10px; float: left; } / 如果两个div在一个块中没有浮动，margin会合并 / .baba .erzi{ height: 100px; background:green; float: left; width: 400px; margin:10px; }‘’’加了浮动的效果：没有加浮动的效果： 很容易就看出区别了啊！加了浮动的爸爸触发了BFC所以把儿子给包起来了，而没有加浮动的爸爸就管不到儿子啦。我理解得是用以上mdn写出的所有方式触发了BFC之后，元素将会形成一个独立的块，不与外界有任何联系了，并且可以完整的包括所有浮动的儿子，这个功能我理解为：爸爸管儿子；嘿嘿嘿； 但是！！敲黑板！！浮动的子元素也会触发BFC啊！那么子元素里面的子元素该由谁管呢，当然由它的父级元素管啦，不再由爷爷辈元素管啦，官方含义的话，去看MDN的解释哦！所以啊 mdn，css官方文档看不懂的话，就寄几去试吧 并且我认为：BFC并没有定义，有的只是特性或者功能；类似于这种说法，我不知道什么是BFC,但是你写出样式，我就知道啦。 BFC与文档流又是啥关系呢虽然一个元素触发了BFC 但是它里面仍然是有文档流的啦 只是这个元素的高度计算方式发生了改变而已，文档流并没有发生任何改变 我的理解来了我曾经看到过，有一些人用BFC去清除浮动，当时年少轻狂的我，觉得好厉害啊好神奇啊好牛逼啊，然鹅理解了BFC之后 我？？？为啥要这样清除浮动？？clearfix不是很好吗？直接display：flex不是很好吗？触发BFC要用到float啊visibility啊这样不是会发生很多bug吗？ 又看了很多博客的我回来了目前我觉得正确的理解是： BFC 并不是给前端用的东西，而是给浏览器开发者用的东西，让浏览器开发者知道div的边界在naer如果实际开发中去刻意使用BFC，我觉得应该会出现很多问题吧，css应该会有更好的解决方案；]]></content>
      <categories>
        <category>share</category>
      </categories>
      <tags>
        <tag>BFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack入门]]></title>
    <url>%2F2018%2F03%2F07%2Fwebpack%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[为什么要使用WebPack 模块化，让我们可以把复杂的程序细化为小的文件; 类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别； Scss，less等CSS预处理器… 什么是Webpack Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。 我们可以直接使用 require(XXX) 的形式来引入各模块，即使它们可能需要经过编译（比如JSX和sass），但我们无须在上面花费太多心思，因为 webpack 有着各种健全的加载器（loader）在默默处理这些事情。 如何使用WebPack安装Webpack可以使用npm安装，新建一个空的练习文件夹（此处命名为webpack sample project），在终端中转到该文件夹后执行下述指令就可以完成安装。 //全局安装 npm install -g webpack webpack-dev-server ###配置 每个项目下都必须配置有一个 webpack.config.js ，配置项，告诉 webpack 它需要做什么。 以下是一个示例: // webpack.config.js module.exports = { entry: &apos;./main.js&apos;, output: { filename: &apos;bundle.js&apos; } }; entry 是页面入口文件配置，output 是对应输出项配置（即入口文件最终要生成什么名字的文件、存放到哪里; 运行 webpack在有了webpack.config.js这个文件之后，你可以调用Webpack且不需要任何参数。 $ webpack 一些你应该知道的命令行选项 webpack– for building once for development(用于构建一个开发目录) webpack -p– for building once for development(用于构建一个生产目录(压缩过的)) webpack –watch– for continuous incremental build(用于连续地构建) webpack -d– to include source maps(展示映射关系) webpack –colors– for making things pretty(用于美化展示的信息) To produce a production ready application(为了产生生产准备的应用)，你可以在package.json编写以下scripts字段 // package.json { // ... &quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack-dev-server --devtool eval --progress --colors&quot;, &quot;deploy&quot;: &quot;NODE_ENV=production webpack -p&quot; }, // ... } 一切皆模块Webpack有一个不可不说的优点，它把所有的文件都都当做模块处理，JavaScript代码，CSS和fonts以及图片等等通过合适的loader都可以被处理。 entryfileEntry file(入口文件)将会被作为webpack读取并构造出bundle.js.举例来说main.js就是一个(entry file)入口文件； // main.jsdocument.write(&apos;&lt;h1&gt;Hello World&lt;/h1&gt;&apos;); index.html &lt;html&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;html&gt; webpack会根据webpack.config.js来构建出bundle.js // webpack.config.js module.exports = { entry: &apos;./main.js&apos;, output: { filename: &apos;bundle.js&apos; } }; Multiple entry files (多入口文件)(资源)多入口文件是合法的，它通常被应用于一个多页应用app // main1.js document.write(&apos;&lt;h1&gt;Hello World&lt;/h1&gt;&apos;); // main2.js document.write(&apos;&lt;h2&gt;Hello Webpack&lt;/h2&gt;&apos;); //index.html &lt;html&gt; &lt;body&gt; &lt;script src=&quot;bundle1.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;bundle2.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;html&gt; //webpack.config.js module.exports = { entry: { bundle1: &apos;./main1.js&apos;, bundle2: &apos;./main2.js&apos; }, output: { filename: &apos;[name].js&apos; } }; Babel-loader(编译器可以将es6语法转成低版本[如es5语法]提高兼容性) loaders(加载器)是可以转换您的应用程序资源(更多信息)文件的一个预处理器，例如Babel-loader可以将JSX / ES6文件转换为JS文件。 main.jsx const React = require(&apos;react&apos;); const ReactDOM = require(&apos;react-dom&apos;); ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.querySelector(&apos;#wrapper&apos;) ); index.html &lt;html&gt; &lt;body&gt; &lt;div id=&quot;wrapper&quot;&gt;&lt;/div&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; webpack.config.js module.exports = { entry: &apos;./main.jsx&apos;, output: { filename: &apos;bundle.js&apos; }, module: { loaders:[ { test: /\.js[x]?$/, exclude: /node_modules/, loader: &apos;babel-loader?presets[]=es2015&amp;presets[]=react&apos; }, ] } }; 在webpack.config.js中，module.loaders字段用于分配加载程序。上面的代码片段使用babel-loader，它还需要插件 babel-preset-es2015 和babel-preset-react对 ES6和React进行transpile(转义)。 您也可以使用其他方式设置babel配置选项。 module: { loaders: [ { test: /\.jsx?$/, exclude: /node_modules/, loader: &apos;babel&apos;, query: { presets: [&apos;es2015&apos;, &apos;react&apos;] } } ] } package.json { &quot;devDependencies&quot;: { &quot;babel-core&quot;: &quot;^6.21.0&quot;, &quot;babel-loader&quot;: &quot;^6.2.10&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.18.0&quot;, &quot;babel-preset-react&quot;: &quot;^6.16.0&quot;, &quot;react&quot;: &quot;^15.4.2&quot;, &quot;react-dom&quot;: &quot;^15.4.2&quot; } } 模块引入HTML直接在页面引入 webpack 最终生成的页面脚本即可； js各脚本模块可以直接使用 commonJS 来书写，并可以直接引入未经编译的模块，比如 JSX、sass、coffee等（只要你在 webpack.config.js 里配置好了对应的加载器）。 csswebpack提供两个工具处理样式表，css-loader 和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(…)的方法实现 require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。 //安装 npm install –save-dev style-loader css-loader CSS module模块使得开发者把复杂的代码转化为小的，干净的，依赖声明明确的单元，配合优化工具，依赖管理和加载管理可以自动完成。 被称为CSS modules的技术意在把JS的模块化思想带入CSS中来，通过CSS模块，所有的类名，动画名默认都只作用于当前模块。Webpack对CSS模块化提供了非常好的支持，只需要在CSS loader中进行简单配置即可，然后就可以直接把CSS的类名传递到组件的代码中，这样做有效避免了全局污染。具体的代码如下 { test: /.css$/, use: [ { loader: “style-loader” }, { loader: “css-loader”, options: { modules: true, // 指定启用css modules localIdentName: ‘[name]__[local]–[hash:base64:5]’ // 指定css的类名格式 } } ] } loaders通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React的中用到的JSX文件转换为JS文件。 Loaders需要单独安装并且需要在webpack.config.js中的modules关键字下进行配置，Loaders的配置包括以下几方面： test: 一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）； loader：loader的名称（必须）； include/exclude：手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； query：为loaders提供额外的设置选项（可选）。 Babel的安装与配置Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-env-preset包和解析JSX的babel-preset-react包）。 一次性安装这些依赖包 // npm一次性安装多个依赖模块，模块之间用空格隔开 npm install –save-dev babel-core babel-loader babel-preset-env babel-preset-react 插件plugins插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。 使用插件的方法要使用某个插件，我们需要通过npm安装它，然后要做的就是在webpack配置中的plugins关键字部分添加该插件的一个实例（plugins是一个数组）继续上面的例子，我们添加了一个给打包后代码添加版权声明的插件。 plugins: [ new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;) ]]]></content>
      <categories>
        <category>模块化开发</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[package.json文件]]></title>
    <url>%2F2018%2F03%2F06%2Fpackage-json%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近组里的师傅布置看了项目的源代码，然后发现对package.json这个文件不是很了解，于是看了阮一峰的博客，嘿嘿，以下是我的一点笔记： 概述每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。一个最简单的package.json文件，只定义两项元数据:项目名称和项目版本： { “name”: “xxx”, “version”: “0.0.0” } package.json文件就是一个JSON对象，该对象的每一个成员就是当前项目的一项设置。比如name就是项目名称，version是版本（遵守“大版本.次要版本.小版本”的格式）。 package.json文件的各个字段。scripts 字段scripts 制定了运行脚本命令的npm命令行缩写，比如start指定了运行npm run start时，所要执行的命令。 dependencie,devDependencies字段它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。 { &quot;devDependencies&quot;: { &quot;browserify&quot;: &quot;~13.0.0&quot;, &quot;karma-browserify&quot;: &quot;~5.0.1&quot; } } 指定版本：比如1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。 波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。 插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。latest：安装最新版本。 package.json文件可以手工编写，也可以使用npm init命令自动生成。 这个命令采用互动方式，要求用户回答一些问题，然后在当前目录生成一个基本的package.json文件。所有问题之中，只有项目名称（name）和项目版本（version）是必填的，其他都是选填的。 有了package.json文件，直接使用npm install命令，就会在当前目录中安装所需要的模块。 如果一个模块不在package.json文件之中，可以单独安装这个模块，并使用相应的参数，将其写入package.json文件之中。 $ npm install express –save $ npm install express –save-dev 上面代码表示单独安装express模块，–save参数表示将该模块写入dependencies属性，–save-dev表示将该模块写入devDependencies属性。 peerDependencies有时，你的项目和所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，你的项目依赖A模块和B模块的1.0版，而A模块本身又依赖B模块的2.0版。 大多数情况下，这不构成问题，B模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。 最典型的场景就是插件，比如A模块是B模块的插件。用户安装的B模块是1.0版本，但是A插件只能和2.0版本的B模块一起使用。这时，用户要是将1.0版本的B的实例传给A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果A和B一起安装，那么B必须是2.0模块。 peerDependencies字段，就是用来供插件指定其所需要的主工具的版本。 { “name”: “chai-as-promised”, “peerDependencies”: { “chai”: “1.x” } } 上面代码指定，安装chai-as-promised模块时，主程序chai必须一起安装，而且chai的版本必须是1.x。如果你的项目指定的依赖是chai的2.0版本，就会报错。 注意，从npm 3.0版开始，peerDependencies不再会默认安装了。 binbin项用来指定各个内部命令对应的可执行文件的位置。 &quot;bin&quot;: { &quot;someTool&quot;: &quot;./bin/someTool.js&quot; } 上面代码指定，someTool 命令对应的可执行文件为 bin 子目录下的 someTool.js。Npm会寻找这个文件，在node_modules/.bin/目录下建立符号链接。在上面的例子中，someTool.js会建立符号链接npm_modules/.bin/someTool。由于node_modules/.bin/目录会在运行时加入系统的PATH变量，因此在运行npm时，就可以不带路径，直接通过命令来调用这些脚本。 因此，像下面这样的写法可以采用简写。 scripts: { start: ‘./node_modules/someTool/someTool.js build’ } // 简写为 scripts: { start: &apos;someTool build&apos; } 所有node_modules/.bin/目录下的命令，都可以用npm run [命令]的格式运行。在命令行下，键入npm run，然后按tab键，就会显示所有可以使用的命令。 main字段main字段指定了加载的入口文件，require(‘moduleName’)就会加载这个文件。这个字段的默认值是模块根目录下面的index.js。 configconfig字段用于添加命令行的环境变量。下面是一个package.json文件。 { &quot;name&quot; : &quot;foo&quot;, &quot;config&quot; : { &quot;port&quot; : &quot;8080&quot; }, &quot;scripts&quot; : { &quot;start&quot; : &quot;node server.js&quot; } } 然后，在server.js脚本就可以引用config字段的值。 http .createServer(...) .listen(process.env.npm_package_config_port) 用户执行npm run start命令时，这个脚本就可以得到值。 $ npm run start 用户可以改变这个值。 $ npm config set foo:port 80]]></content>
      <categories>
        <category>模块化开发</category>
      </categories>
      <tags>
        <tag>javascript-package</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法]]></title>
    <url>%2F2018%2F03%2F04%2F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[输入：一个算法必须有零个或以上输入量输出：一个算法应有一个或以上输出量，输出量是算法计算的结果 明确性：算法的描述必须无歧义，以保证算法的实际执行结果是精确的匹配要求或期望，通常要求实际运行结果是确定的；有限性：依据图灵的定义，一个算法是能够被任何图灵完备系统模拟的一串运算，而图灵机只有有限个状态，有限个输入符号和有限个转移函数（指令），而一些定义更规定算法必须在有限个步骤内完成任务。有效性：又称可行性。能够实现，算法中描述的操作都是可以通过已经实现的基本预算执行有限次来实现；什么是数据结构 1 我们要解决一个跟数据相关的问题 2 分析这个问题需要什么对应的数据结构 3 分析数据结构，想出算法###数据结构和算法相互依存、不可分开 算法大分类：分治法：把一个问题分区成互相独立的多个部分分别求解的思路，这种求解思路带来的好处之一就是便于进行并行计算（国省市的思路）；动态规划法：当问题的整体最优解就是由局部最优解组成的时候，经常采用的一种方法。（就目前的情况来看 如果这个就是最好的 那就是最好的）贪婪算法：常见的近似求解思路。当问题的整体最优解不是（或无法证明是）由局部最优解组成，且对解的最优性没有要求的时候，可以采用的一种方法。（不是最好的 看起来是最容易取得的）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2018%2F03%2F02%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[一、二叉树的概念在计算机科学中，二叉树是每个节点最多有两个子数的树结构。通常子树被称作“左子树”和“右子树”。二叉树的每个结点最多只有二颗子树（不存在度大于2的结点），二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2^i-1个节点；深度为k的二叉树至多有2^k-1个结点，对任何一颗二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。 树和二叉树的三个主要差别： 树的结点个数至少为1，而二叉树的结点个数可以为0 数中结点的最大度数没有限制，而二叉树结点的最大度数为2 数的结点无左、右之分，而二叉树的结点有左、右之分 二叉树又分为完全二叉树（complete binary tree）和满二叉树（full binary tree） 满二叉树：一颗深度为k，且有2^k-1个节点称之为满二叉树 完全二叉树：深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中序号为1至n的节点对应时，称之为完全二叉树。 二、什么是堆堆可以视为一颗完全的二叉树，完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示），每一个结点对应数组中的一个元素。 对于给定的某个结点的下标 i，可以很容易的计算出这个结点的父结点、孩子结点的下标： Parent(i) = floor(i/2)，i 的父节点下标 Left(i) = 2i，i 的左子节点下标 Right(i) = 2i + 1，i 的右子节点下标 二叉堆一般分为两种：最大堆和最小堆 最大堆： 最大堆中的最大元素值出现在根结点（堆顶） 堆中每个父节点的元素值都大于等于其孩子结点（如果存在） 最小堆： 最小堆中的最小元素值出现在根结点（堆顶）堆中每个父节点的元素值都小于等于其孩子结点（如果存在） 三、堆排序原理堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束，在堆中定义一下几种操作： 最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点 创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆 堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算 数组都是 Zero-Based，这就意味着我们的堆数据结构模型要发生改变相应的，几个计算公式也要作出相应调整： Parent(i) = floor((i-1)/2)，i 的父节点下标 Left(i) = 2i + 1，i 的左子节点下标 Right(i) = 2(i + 1)，i 的右子节点下标]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局]]></title>
    <url>%2F2018%2F02%2F28%2Fflex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[一、Flex 布局是什么？Flex：Flexible Box - 弹性布局。用来为盒状模型提供最大的灵活性；任何一个容器都可以指定为Flex布局； .box{ display: flex; } 行内元素也可以使用Flex布局.box{ display: inline-flex; } Tips:设为Flex布局以后，子元素的float、clear和vertical-align属性将失效；二、基本概念采用Flex布局的元素，称为Flex容器。它的所有子元素自动称为容器成员，称为Flex项目。三、容器的属性一下6个属性可以设置在容器上： 1 - flex-directionflex-direction 属性决定主轴方向（即项目的排列方向）。.box{ flex-direction: row | row-reverse | column | column-reverse } row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 2 - flex-wrapflex-wrap : 默认情况下，项目都排在一条线上，flex-wrap属性定义，如果一条轴线排不下，如何换行.box{ flex-wrap: nowrap | wrap | wrap-reverse; } nowrap(默认): 不换行； wrap: 换行，第一行在上方； wrap-reverse: 换行，第一行在下方； 3 - flex-flowflex-flow 属性是 flex-derection属性和flex-wrap属性的简写形式，默认值为 row nowarp；.box { flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; } 4 - justify-contentjustify-content属性定义了项目在主轴上的对齐方式.box { justify-content: flex-start | flex-end | center | space-between | space-around; } flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 5 - align-itemsaligh-items 属性定义项目在交叉轴上如何对齐；.box { align-items: flex-start | flex-end | center | baseline | stretch; } flex-start：交叉轴的起点对齐（上对齐）。 flex-end：交叉轴的终点对齐（下对齐）。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 6 - align-contentalign-content 属性定义了多根轴线的对齐方式，如果项目只有一根轴线，改属性不起作用；.box { align-content: flex-start | flex-end | center | space-between | space-around | stretch; } flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性以下6个属性可以设置在项目上；1 - orderorder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0；2 - flex-growflex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。.item { flex-grow: &lt;number&gt;; /* default 0 */ } 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍； 3 - flex-shrinkflex-shrink 属性定义了项目的缩小比例，默认为1，如果空间不足，该项目将缩小； 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 4 - flex-basisflex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算十周是否有多余空间；它的默认值为auto，即项目的本来大小；.item { flex-basis: &lt;length&gt; | auto; /* default auto */ } 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 5 - flexflex属性是flex-grow，flex-shrink和flex-basis的简写，默认值是 0 1 auto。后面两个属性可选；.item { flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt; || &lt;&apos;flex-basis&apos;&gt; ] } 该属性有两个快捷值：auto（1 1 auto）和none（0 0 auto）建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值； 6 - align-selfalign-self属性允许单个项目有与其它项目不一样的对齐方式，可覆盖align-items属性。默认值是auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch；.item { align-self: auto | flex-start | flex-end | center | baseline | stretch; } 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我对于css布局与定位的理解 2]]></title>
    <url>%2F2018%2F02%2F28%2F%E6%88%91%E5%AF%B9%E4%BA%8Ecss%E5%B8%83%E5%B1%80%E4%B8%8E%E5%AE%9A%E4%BD%8D%E7%9A%84%E7%90%86%E8%A7%A3-1%2F</url>
    <content type="text"><![CDATA[1 position 的5个取值1 - sticky最近才了解到这个元素 费了点时间去了解了下原理 mdn的解释是：It’s treated as relatively positioned until it’s containing block crosses a specified threshold (such as setting top to value other than auto) within it’s flow root (or the container it scrolls within), at which point it is treated as “stuck” until meeting the opposite edge of it’s containing block sticky 是容器相关的，也就说 sticky 的特性只会在他所处的容器里生效。 使用 position:sticky 实现粘性布局 这里放一个我觉得写得还不错的博客 供大家参考 他把sticky的原理都介绍的很清楚 2 - static static 是默认值，任何 position：static；的元素都不会被特殊的定位； 即 一个static元素表示它不会被positioned，如果想要快速恢复一些定位设置就可以用这个属性。 3 - relative 在一个相对定位的元素上设置 top left right bottom 这些值时，会使元素偏离其正常的位置，其它的元素位置则不会受改元素的影响发生位置改变来弥补它偏离后剩下的空隙 4 - fixed 一个固定定位的元素会相对于视窗来定位，这意味着即使页面滚动，它还是会停留在相同的位置。 一个固定定位的元素不会保留它原本在页面应有的空隙-即脱离了文档流，不会再参与决定其父级元素的高度。 5 - absolute 绝对定位的元素相对于最近的“positioned”的祖先元素，如果绝对定位的元素没有positioned的祖先元素，那么它将相对于body的元素进行定位；]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我对于css布局与定位的理解 1]]></title>
    <url>%2F2018%2F02%2F28%2F%E6%88%91%E5%AF%B9%E4%BA%8Ecss%E5%B8%83%E5%B1%80%E4%B8%8E%E5%AE%9A%E4%BD%8D%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[最近看了下之前的笔记，决定整理一下放在博客上面，如果有理解得不对的地方，还望指出！ 1 高度是由什么决定的内联元素内联元素的高度：跟字体有关系，但是可以设置高度和行高来规定内联元素的高度；例如一个span标签中的字体，设置字体为12px，实际上并没有12px；一般内联元素的高度，都跟字体有直接关系。 块级元素块级元素的高度：由其内部文档流元素的高度总和决定 - 什么是文档流？文档流的英文是: Normal Flow 我觉得英文的意思可能更准确一点，文档流就是文档内元素的流动方向； 内联元素：* 内联元素从左往右流动，如果宽度不够时，就会自动向下换行继续流动，但是当内联元素出现很长的英文单词时，此单词则不会换行分开。 * 如果希望换行可以在css中使用word-break:break-all 会把每个字都分开。 块级元素：* 每一个块都占一行，从上往下依次流动 * 其高度又块级元素内部的文档流元素的高度总和决定 2 宽度是由什么决定的块级元素的宽度是100%； 而内联元素则是根据其自身的内容或子元素来决定其宽度。 3 line-box 此处引自 mooonx 想要清晰的明白（二）CSS 盒模型Block box与Line box 每一行称为一条Line Box，它又是由这一行的许多inline-box组成，它的高度可以直接由line-height决定，line boxes的高度垂直堆叠形成了containing box的高度，就是我们见到的div或是p标签之类的高度了。 匿名文本&lt;div&gt;当你只有一把锤子&lt;span&gt;一切看起来&lt;/span&gt;都像是颗钉子&lt;/div&gt; 未包含在行内元素的字符串（当你只有一把锤子，都像颗钉子）就叫匿名文本 内容区 行内框 间距内容区 css假设每个元素都会生成一个或者多个Box，称为元素框，元素框中心有内容区，内容区外周围包括了padding，border，margin，但是，替换元素是包括外边距，内边距，边框的。 行间距 行间距是font-size与line-height的差值，被分成两半在内容区的上下 行内框 非替换元素，行内框高度=line-height 替换元素，行内框高度=内容区宽度（行间距不应用到替换元素） 行高 两行文字基线的距离 行框 一行有很多行内框，行框是包含这一行行内框最高点和最低点的 基线 不同元素的基线位置不同，整个行框会有一个基线，行内元素的位置是基于两者基线对齐 4盒模型盒模型 关于盒模型 mdn是这样定义的：在一个文档中，每个元素都被表示为一个矩形的盒子。确定这些盒子的尺寸, 属性 — 像它的颜色，背景，边框方面 — 和位置是渲染引擎的目标。 需要记住的是：”every element in web design is a rectangular box”。如图： CSS3中新增了一种盒模型计算方式：box-sizing 盒模型默认的值是content-box, 新增的值是padding-box和border-box，几种盒模型计算元素宽高的区别如下： content-box（默认）布局所占宽度Width： Width = width + padding-left + padding-right + border-left + border-right 布局所占高度Height: Height = height + padding-top + padding-bottom + border-top + border-bottom padding-box布局所占宽度Width： Width = width(包含padding-left + padding-right) + border-top + border-bottom 布局所占高度Height: Height = height(包含padding-top + padding-bottom) + border-top + border-bottom border-box布局所占宽度Width： Width = width(包含padding-left + padding-right + border-left + border-right) 布局所占高度Height: Height = height(包含padding-top + padding-bottom + border-top + border-bottom) margin叠加外边距叠加是一个相当简单的概念。 简单的说，当两个或更多个垂直边距相遇时，它们将形成一个外边距。这个外边距的高度等于两个发生叠加的外边距的高度中的较大者。 ####但是注意只有普通文档流中块框的垂直外边距才会发生外边距叠加。 行内框、 浮动框或绝对定位框之间的外边距不会叠加。 一般来说， 垂直外边距叠加有三种情况：元素自身叠加 当元素没有内容（即空元素）、内边距、边框时，它的上下边距就相遇了， 即会产生叠加（垂直方向）。当为元素添加内容、内边距、边框任何一项， 就会取消叠加。 相邻元素叠加 相邻的两个元素，如果它们的上下边距相遇，即会产生叠加。包含（父子）元素叠加 包含元素的外边距父元素的内边距和边框， 当这两项都不存在的时候，父子元素垂直外边距相邻，产生叠加。添加任何一项即会取消叠加。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2018%2F02%2F26%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1 配置github 进入 https://github.com/settings/keys 点击 New SSH key，你需要输入 Title 和 Key，但是你现在没有 key 打开 Git Bash 运行 ssh-keygen -t rsa -b 4096 -C “你的邮箱”，注意填写你的邮箱！ 按回车三次 运行 cat ~/.ssh/id_rsa.pub，得到一串东西，完整的复制这串东西 回到上面第 3 步的页面，在 Title 输入「我的第一个 key」 在 Key 里粘贴刚刚你你复制的那串东西 点击 Add SSH key 回到 Git Bash 运行 ssh -T git@github.com，你可能会看到这样的提示： 如果你看到hi！xxx 那么你就成功啦！ tips： 一台电脑只需要一个 SSH key 一个 SSH key 可以访问你的所有仓库，即使你有 1000000 个仓库，都没问题 2 配置gitgit config --global user.name 你的英文名 git config --global user.email 你的邮箱 git config --global push.default matching git config --global core.quotepath false git config --global core.editor &quot;vim&quot; 五句话，依次运行。 3 只在本地使用git-初始化 创建目录作为我们的项目目录：mkdir git-demo 进入目录 cd git-demo git init 这句命令会在git-demo里创建一个.git目录 在git-demo目录里面添加任意文件假设我们添加了两个文件，分别是 index.html 和 css/style.css touch index.html mkdir css touch css/style.css 运行 git status -sb 可以看到文件前面有 ?? 号 Initial commit on master ?? css/ ?? index.html这个 ?? 表示git不知道你要怎么对待这些变动。 使用 git add 将文件添加到「暂存区」 #####你可以一个一个地 add git add index.html git add css/style.css #####你也可以一次性 add git add . 意思是把当前目录（.表示当前目录）里面的变动都加到「暂存区」 再次运行 git status -sb，可以看到 ?? 变成了 A Initial commit on master A css/style.css A index.html #####A 的意思就是添加，也就是说你告诉 git，这些文件我要加到仓库里 使用 git commit -m “信息” 将你 add 过的内容「正式提交」到本地仓库（.git就是本地仓库），并添加一些注释信息，方便日后查阅#####你可以一个一个地 commit git commit index.html -m ‘添加index.html’ git commit css/style.css -m “添加 css/style.css” #####你也可以一次性 commit git commit . -m “添加了几个文件” 再再次运行 git status -sb，发现没有文件变动了，这是因为文件的变动已经记录在仓库里了。 这时你可以使用 git log 就可以看到历史上的变动： commit f0d95058cd32a332b98967f6c0a701c64a00810a Author: frankfang &#102;&#114;&#97;&#x6e;&#x6b;&#x66;&#x61;&#x6e;&#103;&#x31;&#x39;&#x39;&#x30;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109; Date: Thu Sep 28 22:30:43 2017 +0800 以上就是 git add / git commit -文件变动如果想继续改文件，应该怎么做呢？ start css/style.css 会使用默认的编辑器打开 css/style.css然后修改 css/style.css 文件 运行 git status -sb 发现提示中有一个 M master M css/style.css #####这个 M 的意思就是 Modified，表示这个文件被修改了 此时你如果想让改动保存到仓库里，你需要先 git add css/style.css 或者也可以 git add . 注意，由于这个 css/style.css 以前被我们 add 过，你往文章上面看，我们是 add 过 css/style.css 的，所以此处的 git add 操作可以省略。 再次运行 git status -sb 发现 M 有红色变成了绿色 运行 git commit -m “更新 css/style.css”，这个改动就被提交到 .git 本地仓库了。 再再次运行 git status -sb，会发现没有变更了，这说明所有变动都被本地仓库记录在案了。tips:git status -sb 是什么意思： git status 是用来显示当前的文件状态的，哪个文件变动了，方便你进行 git add 操作。 -sb 选项的意思就是，-s 的意思是显示总结（summary），-b 的意思是显示分支（branch），所以 -sb 的意思是显示总结和分支。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于html一些标签，我的理解]]></title>
    <url>%2F2018%2F02%2F26%2F%E5%85%B3%E4%BA%8Ehtml%E4%B8%80%E4%BA%9B%E6%A0%87%E7%AD%BE%EF%BC%8C%E6%88%91%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[写得可能有点杂乱无章 这里整理一下我遇到的一些常见标签 和我自己的理解 嘿嘿 1 iframe 标签嵌套页面&lt;iframe src=&quot;https://www.baidu.com&quot; name=&quot;xxx&quot;&gt;&lt;/iframe&gt; iframe 可以跟a标签结合着用，设置iframe的name属性，并且把a标签的target设置为iframe的name，这样就可以让a标签通过name指向iframe啦！ iframeborder 消除frame的边框 对于iframe到底好不好用的问题 我在知乎上找到一个我觉得不错的回答：HTML：The iframe element represents a nested browsing context. 所以如果你需要独立的浏览上下文，那么就用 iframe，否则就不用。历史上，iframe 常被用于复用部分界面，但是多数情况下并不合适。 现在，应该使用 iframe 的例子如： 沙箱隔离。 引用第三方内容。 独立的带有交互的内容，比如幻灯片。 需要保持独立焦点和历史管理的子窗口，如复杂的Web应用。注：登录弹窗用 iframe 未必合适。HTML标准新增了dialog元素，可能更适合。 作者：贺师俊链接：https://www.zhihu.com/question/20653055/answer/17786008来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2 a 标签跳转页面（HTTP GET 请求） _blank 在空白页面打开 _self 在自身页面打开 _parent 在父级页面打开 _top 在最顶级页面打开 例如：&lt;a target=&quot;_top&quot; href=&quot;xxx&quot;&gt;在最顶层页面或者iframe中打开 &lt;a target=&quot;xxx&quot; href=&quot;xxx&quot;&gt; 在name为xxx的窗口或者iframe中打开 a 标签还可以这样写&lt;a href=&quot;?name=111&quot;&gt; 相当于在url请求后面ping了个name的参数。 意思是请求体重加了一个name=111的条件 a 标签还可以支持无协议链接&lt;a href=&quot;//qq.html&quot;&gt; 浏览器会根据当前协议，补全无协议链接的协议 but 如果用file://无协议链接 ，就会访问到file://qq.com 这是一个不存在的路径 javascript 伪协议&lt;a href=&quot;javascript:;&quot;&gt; 当遇到不希望点击a标签不跳转的时候可以使用； but 为什么要有JavaScript伪协议呢 可以在用户点击a标签时执行一段JavaScript代码 在地址栏输入JavaScript:alert(1)可以在当前页面执行一段代码 伪协议可以实现点击之后没有任何动作的a标签 3 form 标签&lt;form action=&quot;xxx&quot; method=&quot;POST&quot;&gt; form可以用method属性指定用POST还是GET请求 but 如果form表单没有提交按钮 就无法提交这个表单提交按钮可以由两种方式实现 &lt;input type=&quot;submit&quot;&gt; &lt;button&gt;submit&lt;/button&gt; 此处的input 的type必须是submit 而button不能指定type，因为button在form里面的默认type即是submit，如果指定了其它type，那么button将不再具有submit功能 input和button的区别在于是否为空标签； 4 input 标签与文字关联的checkbox① 使用label将复选框和文字组合起来 &lt;input type=checkbox id=xxx name=xxx&gt;&lt;label for=&quot;xxx&quot; value=&quot;ss&quot;&gt;xxxx&lt;/lable&gt; ② 用label包含整个标签 &lt;label&gt;xxx&lt;input type=checkbox name=xxx value=ss&gt;&lt;/label&gt; but 如果input不加name，在表单提交时，input的值就不会出现在请求里。radio&lt;input name=xx type=radio value=xx&gt; &lt;input name=xx type=radio value=yy&gt; 当设置相同name时 便可设置成单选框 5 select 标签&lt;select name=&quot;group&quot;&gt; &lt;option value=&quot;&quot;&gt;-&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;第一组&lt;/option&gt; &lt;option value=&quot;2&quot; disabled&gt;第二组&lt;/option&gt; &lt;option value=&quot;3&quot; selected&gt;第三组&lt;/option&gt; 注意:按住control select是可以多选的6 table 标签html规定table的子元素只有：thead,tbody,tfoot,colgroup tips: 不管thead，tbody…怎么放顺序，浏览器都会给你纠正..&lt;colgroup&gt; &lt;col width= bgcolor&gt;/第1列 &lt;col width=&gt;第2列 &lt;/colgroup&gt; colgroup应该算是比较冷僻的元素了 它可以直接规定每列的样式，不用再给每个td一个classname然后设置style了； 嘿嘿 标签就整理到这里 如有疏漏还请指出！]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于HTML]]></title>
    <url>%2F2018%2F02%2F25%2F%E5%85%B3%E4%BA%8Ehtml%2F</url>
    <content type="text"><![CDATA[W3C 引自维基百科 1 万维网联盟（World Wide Web Consortium，W3C），又称W3C理事会，是万维网的主要国际标准组织&nbsp;&nbsp;万维网联盟（W3C）由蒂姆·伯纳斯-李于1994年10月离开欧洲核子研究中心（CERN）后成立，在欧盟执委会和国防高等研究计划署（DARPA）的支持下成立于麻省理工学院MIT计算机科学与人工智能实验室（MIT／LCS）&nbsp;&nbsp;为解决网络应用中不同平台、技术和开发者带来的不兼容问题，保障网络信息的顺利和完整流通，万维网联盟制定了一系列标准并督促网络应用开发者和内容提供者遵循这些标准。标准的内容包括使用语言的规范，开发中使用的导则和解释引擎的行为等等。W3C也制定了包括XML和CSS等的众多影响深远的标准规范。 MDN Web Docs 引自维基百科 2 MDN Web Docs（旧称Mozilla Developer Network、Mozilla Developer Center，简称MDN）是一个汇集众多Mozilla基金会产品和网络技术开发文档的免费网站。&nbsp;&nbsp;该项目始于2005年，最初由Mozilla公司员工Deb Richardson领导。自2006年以来，文档工作由Eric Shepherd领导。 &nbsp;&nbsp;网站最初的内容是由DevEdge提供，但在AOL收购Netscape后，DevEdge网站也宣布关闭。为此Mozilla基金会向AOL获取了DevEdge发布的内容[3][2]，同时将DevEdge内容搬移到mozilla.org。 HTML所有标签3 什么是空标签MDN 的解释是：An empty element is an element from HTML, SVG, or MathML that cannot have any child nodes；我的理解是空标签就是没有html内容的标签，只需要写一个开始标签。 4 什么是可替换标签可替换元素就是浏览器根据元素的标签和属性，来决定元素的具体显示内容。 例如浏览器会根据img标签的src属性的值来读取图片信息并显示出来，而如果查看(x)html代码，则看不到图片的实际内容；又例如根据input标签的type属性来决定是显示输入框，还是单选按钮等。 (x)html中的img、input、textarea、select、object都是替换元素。这些元素往往没有实际的内容，即是一个空元素 5 是否可以区分块级元素和内联元素我个人的理解是，html并没有块级元素和内联元素之分，有的只是他们自身的默认css样式区分，html不管这个标签的样式，只管这个标签的内容和意义。]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈计算机是如何存储数据的]]></title>
    <url>%2F2018%2F02%2F23%2F%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84%2F</url>
    <content type="text"><![CDATA[以前上计算机原理的课的时候，老师讲得总是不是很浅显易懂，为了防止自己成为井底之蛙，近期又去了解了下，做个笔记吧 计算机就是二进制的世界，只存在0与1 1 那么0和1又是怎么存储的呢 这是一个充电的过程 存储—&gt;1就充电，0就不充电 读取—&gt;电量大于 50% 就是 1，电量小于 50% 就是 0 2 如何存储字符？ ####将每个字符编号 ASCII 美国信息交换标准代码 如果你想储存 a，那么就储存 97 对应的二进制a -&gt; 01100 0012 -&gt; 6116 如果你想储存 1，那么就储存 49 对应的二进制1 -&gt; 0011 00012 -&gt; 3116 3 中文如何存储？GB 2312 中国国家标准简体中文字符集 GB2312 共收录 6763 个汉字，同时收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的 682 个字符。 后来为了存储生僻字、繁体字、日语、朝鲜语等，微软推出了 GBK 字符集 4 如何存储所有字符####将全球字符编号 Unicode 字符集包括中日韩文字、藏文、盲文、楔形文字、 颜文字:-)、 绘文字😂 2016年6月时，Unicode 总共有 128237 个字符 5 如何将 Unicode 存到计算机里 ###以一种高性价比的方式 ####低性价比a -&gt; 00000000 00000000 00000000 011000012 = 006116 你 -&gt; 00000000 00000000 01001111 011000002 = 4F6016 #####高性价比 UTF-8a -&gt; 01100001 你-&gt; 11100100 10111101 10100000]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo+gitpages搭建博客]]></title>
    <url>%2F2018%2F02%2F23%2F%E4%BD%BF%E7%94%A8hexo-gitpages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[嘿嘿 最近学习了用hexo搭建博客 下面是本萌新的一些些经验~注：我用的是mac系统 以下是我安装的一些步骤：1.进入一个目录，我是放到documents的~以下以documents示例2.在github上新建一个空的仓库，仓库的名称可以是你的用户名等等等3.打开终端(在这里给大家推荐一个无敌好用终端替代品(iterm2)，具体自行谷歌和百度哦嘿嘿)4.安装hexo npm install -g hexo-cli5.hexo init myBlog(随便你想叫什么名字哈。。)6.cd myBlog7.npm i8.可以在myblog下新建博客啦 hexo new xxxx(xxxx=博客的名字)9.然后会出现一个md文档的路径10.然后就愉快的编辑这个md文件吧 vim xxx.md11.编辑网站设置 vim _config.yml 把第6行的title改成whatever你喜欢的名字 把第9行的author改成你的名字哦 最后一行的type改成 type：git(!!：后面是有空格的) 在最后一行后面新增一行，左边与type平齐。加上一行加上一行 repo: 仓库地址 （请将仓库地址改为「你的用户名.github.io」对应的仓库地址 !!: 这个冒号后面都有空格啊 （不要犯跟我一样的错误啦）12.npm install hexo-deployer-git –save，安装 git 部署插件13.hexo deploy14.进入「你的用户名.github.io」对应的 repo，打开 GitHub Pages 功能，如果已经打开了，就直接点击预览链接嘿嘿嘿 现在应该可以看到你的博客啦~ hexo主题设置对啦 hexo 还有很多主题 嘿嘿1 https://github.com/hexojs/hexo/wiki/Themes 上面有主题合集2 随便找一个主题，进入主题的 GitHub 首页 推荐大家 next3 复制它的 SSH 地址或 HTTPS 地址4 cd themes5 git clone git@github.com:iissnan/hexo-theme-next.git6 cd ..7 将 _config.yml 的第 75 行改为 theme: hexo-theme-next，保存8 hexo generate9 hexo deploy然后刷新博客 嘿嘿 尽情挑选吧]]></content>
      <tags>
        <tag>share</tag>
      </tags>
  </entry>
</search>
